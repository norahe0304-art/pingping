<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star åƒç´ åŠå…¬å®¤</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #1a1a2e; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        #game-container { 
            border: 4px solid #ff6b35; 
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 107, 53, 0.3);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
    // çŠ¶æ€é…ç½®
    const STATE_CONFIG = {
        idle: { zone: 'breakroom', color: '#4ade80', emoji: 'ğŸ˜´' },
        writing: { zone: 'workdesk', color: '#60a5fa', emoji: 'âœï¸' },
        researching: { zone: 'workdesk', color: '#c084fc', emoji: 'ğŸ”' },
        executing: { zone: 'workdesk', color: '#f97316', emoji: 'âš¡' },
        syncing: { zone: 'breakroom', color: '#fbbf24', emoji: 'ğŸ”„' },
        error: { zone: 'breakroom', color: '#ef4444', emoji: 'âŒ' }
    };

    // åŒºåŸŸåæ ‡
    const ZONES = {
        workdesk: { x: 250, y: 300, width: 300, height: 200 },
        breakroom: { x: 550, y: 300, width: 200, height: 200 }
    };

    class OfficeScene extends Phaser.Scene {
        constructor() {
            super({ key: 'OfficeScene' });
            this.character = null;
            this.currentState = 'idle';
            this.blinkTimer = 0;
            this.bubbleTimer = 0;
            this.walkTimer = 0;
            this.isWalking = false;
            this.targetX = 0;
            this.targetY = 0;
        }

        create() {
            // ç»˜åˆ¶åŠå…¬å®¤èƒŒæ™¯
            this.drawOffice();

            // ç»˜åˆ¶åŒºåŸŸæ ‡ç­¾
            this.add.text(250, 180, 'ğŸ–¥ï¸ å·¥ä½œåŒº', { fontSize: '20px', color: '#60a5fa' }).setOrigin(0.5);
            this.add.text(550, 180, 'â˜• ä¼‘æ¯åŒº', { fontSize: '20px', color: '#4ade80' }).setOrigin(0.5);

            // åˆ›å»ºåƒç´ å°äºº
            this.createCharacter();

            // çŠ¶æ€æ˜¾ç¤º
            this.statusText = this.add.text(400, 50, 'ç­‰å¾…ä»»åŠ¡ä¸­...', {
                fontSize: '18px',
                color: '#fff',
                backgroundColor: '#333',
                padding: { x: 10, y: 5 }
            }).setOrigin(0.5);

            // å¯åŠ¨å®šæ—¶è½®è¯¢
            this.time.addEvent({
                delay: 5000,
                callback: this.fetchStatus,
                callbackScope: this,
                loop: true
            });

            this.fetchStatus();
        }

        drawOffice() {
            const graphics = this.add.graphics();
            
            // åœ°æ¿
            graphics.fillStyle(0x2d2d44);
            graphics.fillRect(0, 0, 800, 600);

            // å·¥ä½œåŒº - æœ¨è´¨æ¡Œé¢
            graphics.fillStyle(0x8b5a2b);
            graphics.fillRect(150, 220, 300, 260);
            graphics.fillStyle(0x6b4423);
            graphics.fillRect(150, 220, 300, 20);

            // æ˜¾ç¤ºå™¨
            graphics.fillStyle(0x333);
            graphics.fillRect(220, 180, 80, 50);
            graphics.fillStyle(0x4a90d9);
            graphics.fillRect(225, 185, 70, 40);
            graphics.fillStyle(0x222);
            graphics.fillRect(250, 230, 20, 30);

            // ä¼‘æ¯åŒº - æ²™å‘
            graphics.fillStyle(0x9c27b0);
            graphics.fillRect(500, 350, 150, 60);
            graphics.fillStyle(0x7b1fa2);
            graphics.fillRect(500, 350, 150, 15);

            // å’–å•¡æœº
            graphics.fillStyle(0x607d8b);
            graphics.fillRect(620, 280, 40, 50);
            graphics.fillStyle(0xffd700);
            graphics.fillRect(625, 285, 30, 10);

            // åœ°æ¿è£…é¥°
            graphics.fillStyle(0x3d3d5c);
            for (let i = 0; i < 10; i++) {
                graphics.fillRect(50 + i * 75, 500, 50, 50);
            }
        }

        createCharacter() {
            // åƒç´ å°äºº (16x24)
            this.character = this.add.container(400, 300);
            
            // èº«ä½“
            const body = this.add.graphics();
            body.fillStyle(0xff6b35);
            body.fillRect(-8, -12, 16, 20);
            
            // å¤´
            body.fillStyle(0xffdbac);
            body.fillRect(-6, -20, 12, 10);
            
            // çœ¼ç›
            body.fillStyle(0x000);
            body.fillRect(-4, -18, 2, 2);
            body.fillRect(2, -18, 2, 2);

            // çŠ¶æ€æ°”æ³¡
            this.bubble = this.add.graphics();
            this.character.add(this.bubble);
            this.character.add(body);

            // ä¿å­˜çœ¼ç›ä½ç½®ç”¨äºçœ¨çœ¼
            this.eyeLeft = { x: -4, y: -18 };
            this.eyeRight = { x: 2, y: -18 };
        }

        fetchStatus() {
            fetch('/status')
                .then(r => r.json())
                .then(data => {
                    if (data.state !== this.currentState) {
                        this.currentState = data.state;
                        this.moveToZone(STATE_CONFIG[data.state].zone);
                    }
                    this.statusText.setText(data.detail || STATE_CONFIG[data.state].emoji + ' ' + data.state);
                })
                .catch(e => console.error('Status fetch error:', e));
        }

        moveToZone(zone) {
            const z = ZONES[zone];
            this.targetX = z.x + Math.random() * z.width - z.width/2;
            this.targetY = z.y + Math.random() * z.height - z.height/2;
            this.isWalking = true;
        }

        update(time, delta) {
            if (this.isWalking) {
                const dx = this.targetX - this.character.x;
                const dy = this.targetY - this.character.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 5) {
                    this.character.x += (dx / dist) * 2;
                    this.character.y += (dy / dist) * 2;
                    // èµ°è·¯é¢ ç°¸
                    this.character.y += Math.sin(time / 50) * 0.5;
                } else {
                    this.isWalking = false;
                }
            }

            // çœ¨çœ¼
            this.blinkTimer += delta;
            if (this.blinkTimer > 3000 + Math.random() * 2000) {
                this.blinkTimer = 0;
                // çœ¨çœ¼åŠ¨ç”»
            }

            // éšæœºç§»åŠ¨
            this.walkTimer += delta;
            if (this.walkTimer > 10000) {
                this.walkTimer = 0;
                const config = STATE_CONFIG[this.currentState];
                this.moveToZone(config.zone);
            }
        }
    }

    const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        parent: 'game-container',
        scene: OfficeScene
    };

    const game = new Phaser.Game(config);
    </script>
</body>
</html>
